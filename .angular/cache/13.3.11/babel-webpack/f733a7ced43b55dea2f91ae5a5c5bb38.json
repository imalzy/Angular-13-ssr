{"ast":null,"code":"import _asyncToGenerator from \"/Users/imalzy/Documents/angular/technical-req-angular-13/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { as as _getInstance, at as _assert, au as _signInWithCredential, av as _reauthenticate, aw as _link$1, J as AuthCredential, ax as signInWithIdp, ay as _fail, az as debugAssert, aA as _persistenceKeyName, aB as _castAuth, aC as FederatedAuthProvider, aD as BaseOAuthProvider, aE as _emulatorUrl, aF as _performApiRequest, aG as _isIOS, aH as _isAndroid, aI as _isIOS7Or8, aJ as _createError, aK as _isIframe, aL as _isMobileBrowser, aM as _isIE10, aN as _isSafari } from './totp-e47c784e.js';\nexport { A as ActionCodeOperation, ag as ActionCodeURL, J as AuthCredential, G as AuthErrorCodes, aP as AuthImpl, K as EmailAuthCredential, Q as EmailAuthProvider, U as FacebookAuthProvider, F as FactorId, aR as FetchProvider, W as GithubAuthProvider, V as GoogleAuthProvider, L as OAuthCredential, X as OAuthProvider, O as OperationType, M as PhoneAuthCredential, P as PhoneAuthProvider, m as PhoneMultiFactorGenerator, p as ProviderId, R as RecaptchaVerifier, aS as SAMLAuthCredential, Y as SAMLAuthProvider, S as SignInMethod, T as TotpMultiFactorGenerator, n as TotpSecret, Z as TwitterAuthProvider, aO as UserImpl, at as _assert, aB as _castAuth, ay as _fail, aQ as _getClientVersion, as as _getInstance, aA as _persistenceKeyName, a5 as applyActionCode, w as beforeAuthStateChanged, b as browserLocalPersistence, k as browserPopupRedirectResolver, a as browserSessionPersistence, a6 as checkActionCode, a4 as confirmPasswordReset, I as connectAuthEmulator, a8 as createUserWithEmailAndPassword, D as debugErrorMap, C as deleteUser, ad as fetchSignInMethodsForEmail, ao as getAdditionalUserInfo, o as getAuth, al as getIdToken, am as getIdTokenResult, aq as getMultiFactorResolver, j as getRedirectResult, N as inMemoryPersistence, i as indexedDBLocalPersistence, H as initializeAuth, t as initializeRecaptchaConfig, ab as isSignInWithEmailLink, a0 as linkWithCredential, l as linkWithPhoneNumber, d as linkWithPopup, g as linkWithRedirect, ar as multiFactor, x as onAuthStateChanged, v as onIdTokenChanged, ah as parseActionCodeURL, E as prodErrorMap, a1 as reauthenticateWithCredential, r as reauthenticateWithPhoneNumber, e as reauthenticateWithPopup, h as reauthenticateWithRedirect, ap as reload, ae as sendEmailVerification, a3 as sendPasswordResetEmail, aa as sendSignInLinkToEmail, q as setPersistence, _ as signInAnonymously, $ as signInWithCredential, a2 as signInWithCustomToken, a9 as signInWithEmailAndPassword, ac as signInWithEmailLink, s as signInWithPhoneNumber, c as signInWithPopup, f as signInWithRedirect, B as signOut, an as unlink, z as updateCurrentUser, aj as updateEmail, ak as updatePassword, u as updatePhoneNumber, ai as updateProfile, y as useDeviceLanguage, af as verifyBeforeUpdateEmail, a7 as verifyPasswordResetCode } from './totp-e47c784e.js';\nimport { isEmpty, querystring, getUA, querystringDecode } from '@firebase/util';\nimport 'tslib';\nimport { SDK_VERSION } from '@firebase/app';\nimport '@firebase/component';\nimport 'node-fetch';\nimport '@firebase/logger';\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nfunction _generateEventId(prefix = '', digits = 10) {\n  let random = '';\n\n  for (let i = 0; i < digits; i++) {\n    random += Math.floor(Math.random() * 10);\n  }\n\n  return prefix + random;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nclass AuthPopup {\n  constructor(window) {\n    this.window = window;\n    this.associatedEvent = null;\n  }\n\n  close() {\n    if (this.window) {\n      try {\n        this.window.close();\n      } catch (e) {}\n    }\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Chooses a popup/redirect resolver to use. This prefers the override (which\r\n * is directly passed in), and falls back to the property set on the auth\r\n * object. If neither are available, this function errors w/ an argument error.\r\n */\n\n\nfunction _withDefaultResolver(auth, resolverOverride) {\n  if (resolverOverride) {\n    return _getInstance(resolverOverride);\n  }\n\n  _assert(auth._popupRedirectResolver, auth, \"argument-error\"\n  /* AuthErrorCode.ARGUMENT_ERROR */\n  );\n\n  return auth._popupRedirectResolver;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nclass IdpCredential extends AuthCredential {\n  constructor(params) {\n    super(\"custom\"\n    /* ProviderId.CUSTOM */\n    , \"custom\"\n    /* ProviderId.CUSTOM */\n    );\n    this.params = params;\n  }\n\n  _getIdTokenResponse(auth) {\n    return signInWithIdp(auth, this._buildIdpRequest());\n  }\n\n  _linkToIdToken(auth, idToken) {\n    return signInWithIdp(auth, this._buildIdpRequest(idToken));\n  }\n\n  _getReauthenticationResolver(auth) {\n    return signInWithIdp(auth, this._buildIdpRequest());\n  }\n\n  _buildIdpRequest(idToken) {\n    const request = {\n      requestUri: this.params.requestUri,\n      sessionId: this.params.sessionId,\n      postBody: this.params.postBody,\n      tenantId: this.params.tenantId,\n      pendingToken: this.params.pendingToken,\n      returnSecureToken: true,\n      returnIdpCredential: true\n    };\n\n    if (idToken) {\n      request.idToken = idToken;\n    }\n\n    return request;\n  }\n\n}\n\nfunction _signIn(params) {\n  return _signInWithCredential(params.auth, new IdpCredential(params), params.bypassAuthState);\n}\n\nfunction _reauth(params) {\n  const {\n    auth,\n    user\n  } = params;\n\n  _assert(user, auth, \"internal-error\"\n  /* AuthErrorCode.INTERNAL_ERROR */\n  );\n\n  return _reauthenticate(user, new IdpCredential(params), params.bypassAuthState);\n}\n\nfunction _link(_x) {\n  return _link2.apply(this, arguments);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Popup event manager. Handles the popup's entire lifecycle; listens to auth\r\n * events\r\n */\n\n\nfunction _link2() {\n  _link2 = _asyncToGenerator(function* (params) {\n    const {\n      auth,\n      user\n    } = params;\n\n    _assert(user, auth, \"internal-error\"\n    /* AuthErrorCode.INTERNAL_ERROR */\n    );\n\n    return _link$1(user, new IdpCredential(params), params.bypassAuthState);\n  });\n  return _link2.apply(this, arguments);\n}\n\nclass AbstractPopupRedirectOperation {\n  constructor(auth, filter, resolver, user, bypassAuthState = false) {\n    this.auth = auth;\n    this.resolver = resolver;\n    this.user = user;\n    this.bypassAuthState = bypassAuthState;\n    this.pendingPromise = null;\n    this.eventManager = null;\n    this.filter = Array.isArray(filter) ? filter : [filter];\n  }\n\n  execute() {\n    var _this = this;\n\n    return new Promise( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (resolve, reject) {\n        _this.pendingPromise = {\n          resolve,\n          reject\n        };\n\n        try {\n          _this.eventManager = yield _this.resolver._initialize(_this.auth);\n          yield _this.onExecution();\n\n          _this.eventManager.registerConsumer(_this);\n        } catch (e) {\n          _this.reject(e);\n        }\n      });\n\n      return function (_x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n\n  onAuthEvent(event) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        urlResponse,\n        sessionId,\n        postBody,\n        tenantId,\n        error,\n        type\n      } = event;\n\n      if (error) {\n        _this2.reject(error);\n\n        return;\n      }\n\n      const params = {\n        auth: _this2.auth,\n        requestUri: urlResponse,\n        sessionId: sessionId,\n        tenantId: tenantId || undefined,\n        postBody: postBody || undefined,\n        user: _this2.user,\n        bypassAuthState: _this2.bypassAuthState\n      };\n\n      try {\n        _this2.resolve(yield _this2.getIdpTask(type)(params));\n      } catch (e) {\n        _this2.reject(e);\n      }\n    })();\n  }\n\n  onError(error) {\n    this.reject(error);\n  }\n\n  getIdpTask(type) {\n    switch (type) {\n      case \"signInViaPopup\"\n      /* AuthEventType.SIGN_IN_VIA_POPUP */\n      :\n      case \"signInViaRedirect\"\n      /* AuthEventType.SIGN_IN_VIA_REDIRECT */\n      :\n        return _signIn;\n\n      case \"linkViaPopup\"\n      /* AuthEventType.LINK_VIA_POPUP */\n      :\n      case \"linkViaRedirect\"\n      /* AuthEventType.LINK_VIA_REDIRECT */\n      :\n        return _link;\n\n      case \"reauthViaPopup\"\n      /* AuthEventType.REAUTH_VIA_POPUP */\n      :\n      case \"reauthViaRedirect\"\n      /* AuthEventType.REAUTH_VIA_REDIRECT */\n      :\n        return _reauth;\n\n      default:\n        _fail(this.auth, \"internal-error\"\n        /* AuthErrorCode.INTERNAL_ERROR */\n        );\n\n    }\n  }\n\n  resolve(cred) {\n    debugAssert(this.pendingPromise, 'Pending promise was never set');\n    this.pendingPromise.resolve(cred);\n    this.unregisterAndCleanUp();\n  }\n\n  reject(error) {\n    debugAssert(this.pendingPromise, 'Pending promise was never set');\n    this.pendingPromise.reject(error);\n    this.unregisterAndCleanUp();\n  }\n\n  unregisterAndCleanUp() {\n    if (this.eventManager) {\n      this.eventManager.unregisterConsumer(this);\n    }\n\n    this.pendingPromise = null;\n    this.cleanUp();\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst PENDING_REDIRECT_KEY = 'pendingRedirect'; // We only get one redirect outcome for any one auth, so just store it\n// in here.\n\nconst redirectOutcomeMap = new Map();\n\nclass RedirectAction extends AbstractPopupRedirectOperation {\n  constructor(auth, resolver, bypassAuthState = false) {\n    super(auth, [\"signInViaRedirect\"\n    /* AuthEventType.SIGN_IN_VIA_REDIRECT */\n    , \"linkViaRedirect\"\n    /* AuthEventType.LINK_VIA_REDIRECT */\n    , \"reauthViaRedirect\"\n    /* AuthEventType.REAUTH_VIA_REDIRECT */\n    , \"unknown\"\n    /* AuthEventType.UNKNOWN */\n    ], resolver, undefined, bypassAuthState);\n    this.eventId = null;\n  }\n  /**\r\n   * Override the execute function; if we already have a redirect result, then\r\n   * just return it.\r\n   */\n\n\n  execute() {\n    var _superprop_getExecute = () => super.execute,\n        _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let readyOutcome = redirectOutcomeMap.get(_this3.auth._key());\n\n      if (!readyOutcome) {\n        try {\n          const hasPendingRedirect = yield _getAndClearPendingRedirectStatus(_this3.resolver, _this3.auth);\n          const result = hasPendingRedirect ? yield _superprop_getExecute().call(_this3) : null;\n\n          readyOutcome = () => Promise.resolve(result);\n        } catch (e) {\n          readyOutcome = () => Promise.reject(e);\n        }\n\n        redirectOutcomeMap.set(_this3.auth._key(), readyOutcome);\n      } // If we're not bypassing auth state, the ready outcome should be set to\n      // null.\n\n\n      if (!_this3.bypassAuthState) {\n        redirectOutcomeMap.set(_this3.auth._key(), () => Promise.resolve(null));\n      }\n\n      return readyOutcome();\n    })();\n  }\n\n  onAuthEvent(event) {\n    var _superprop_getOnAuthEvent = () => super.onAuthEvent,\n        _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (event.type === \"signInViaRedirect\"\n      /* AuthEventType.SIGN_IN_VIA_REDIRECT */\n      ) {\n        return _superprop_getOnAuthEvent().call(_this4, event);\n      } else if (event.type === \"unknown\"\n      /* AuthEventType.UNKNOWN */\n      ) {\n        // This is a sentinel value indicating there's no pending redirect\n        _this4.resolve(null);\n\n        return;\n      }\n\n      if (event.eventId) {\n        const user = yield _this4.auth._redirectUserForId(event.eventId);\n\n        if (user) {\n          _this4.user = user;\n          return _superprop_getOnAuthEvent().call(_this4, event);\n        } else {\n          _this4.resolve(null);\n        }\n      }\n    })();\n  }\n\n  onExecution() {\n    return _asyncToGenerator(function* () {})();\n  }\n\n  cleanUp() {}\n\n}\n\nfunction _getAndClearPendingRedirectStatus(_x4, _x5) {\n  return _getAndClearPendingRedirectStatus2.apply(this, arguments);\n}\n\nfunction _getAndClearPendingRedirectStatus2() {\n  _getAndClearPendingRedirectStatus2 = _asyncToGenerator(function* (resolver, auth) {\n    const key = pendingRedirectKey(auth);\n    const persistence = resolverPersistence(resolver);\n\n    if (!(yield persistence._isAvailable())) {\n      return false;\n    }\n\n    const hasPendingRedirect = (yield persistence._get(key)) === 'true';\n    yield persistence._remove(key);\n    return hasPendingRedirect;\n  });\n  return _getAndClearPendingRedirectStatus2.apply(this, arguments);\n}\n\nfunction _clearRedirectOutcomes() {\n  redirectOutcomeMap.clear();\n}\n\nfunction _overrideRedirectResult(auth, result) {\n  redirectOutcomeMap.set(auth._key(), result);\n}\n\nfunction resolverPersistence(resolver) {\n  return _getInstance(resolver._redirectPersistence);\n}\n\nfunction pendingRedirectKey(auth) {\n  return _persistenceKeyName(PENDING_REDIRECT_KEY, auth.config.apiKey, auth.name);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction _getRedirectResult(_x6, _x7) {\n  return _getRedirectResult2.apply(this, arguments);\n}\n\nfunction _getRedirectResult2() {\n  _getRedirectResult2 = _asyncToGenerator(function* (auth, resolverExtern, bypassAuthState = false) {\n    const authInternal = _castAuth(auth);\n\n    const resolver = _withDefaultResolver(authInternal, resolverExtern);\n\n    const action = new RedirectAction(authInternal, resolver, bypassAuthState);\n    const result = yield action.execute();\n\n    if (result && !bypassAuthState) {\n      delete result.user._redirectEventId;\n      yield authInternal._persistUserIfCurrent(result.user);\n      yield authInternal._setRedirectUser(null, resolverExtern);\n    }\n\n    return result;\n  });\n  return _getRedirectResult2.apply(this, arguments);\n}\n\nconst STORAGE_AVAILABLE_KEY = '__sak';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// There are two different browser persistence types: local and session.\n// Both have the same implementation but use a different underlying storage\n// object.\n\nclass BrowserPersistenceClass {\n  constructor(storageRetriever, type) {\n    this.storageRetriever = storageRetriever;\n    this.type = type;\n  }\n\n  _isAvailable() {\n    try {\n      if (!this.storage) {\n        return Promise.resolve(false);\n      }\n\n      this.storage.setItem(STORAGE_AVAILABLE_KEY, '1');\n      this.storage.removeItem(STORAGE_AVAILABLE_KEY);\n      return Promise.resolve(true);\n    } catch (_a) {\n      return Promise.resolve(false);\n    }\n  }\n\n  _set(key, value) {\n    this.storage.setItem(key, JSON.stringify(value));\n    return Promise.resolve();\n  }\n\n  _get(key) {\n    const json = this.storage.getItem(key);\n    return Promise.resolve(json ? JSON.parse(json) : null);\n  }\n\n  _remove(key) {\n    this.storage.removeItem(key);\n    return Promise.resolve();\n  }\n\n  get storage() {\n    return this.storageRetriever();\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nclass BrowserSessionPersistence extends BrowserPersistenceClass {\n  constructor() {\n    super(() => window.sessionStorage, \"SESSION\"\n    /* PersistenceType.SESSION */\n    );\n  }\n\n  _addListener(_key, _listener) {\n    // Listeners are not supported for session storage since it cannot be shared across windows\n    return;\n  }\n\n  _removeListener(_key, _listener) {\n    // Listeners are not supported for session storage since it cannot be shared across windows\n    return;\n  }\n\n}\n\nBrowserSessionPersistence.type = 'SESSION';\n/**\r\n * An implementation of {@link Persistence} of `SESSION` using `sessionStorage`\r\n * for the underlying storage.\r\n *\r\n * @public\r\n */\n\nconst browserSessionPersistence = BrowserSessionPersistence;\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * URL for Authentication widget which will initiate the OAuth handshake\r\n *\r\n * @internal\r\n */\n\nconst WIDGET_PATH = '__/auth/handler';\n/**\r\n * URL for emulated environment\r\n *\r\n * @internal\r\n */\n\nconst EMULATOR_WIDGET_PATH = 'emulator/auth/handler';\n/**\r\n * Fragment name for the App Check token that gets passed to the widget\r\n *\r\n * @internal\r\n */\n\nconst FIREBASE_APP_CHECK_FRAGMENT_ID = encodeURIComponent('fac');\n\nfunction _getRedirectUrl(_x8, _x9, _x10, _x11, _x12, _x13) {\n  return _getRedirectUrl2.apply(this, arguments);\n}\n\nfunction _getRedirectUrl2() {\n  _getRedirectUrl2 = _asyncToGenerator(function* (auth, provider, authType, redirectUrl, eventId, additionalParams) {\n    _assert(auth.config.authDomain, auth, \"auth-domain-config-required\"\n    /* AuthErrorCode.MISSING_AUTH_DOMAIN */\n    );\n\n    _assert(auth.config.apiKey, auth, \"invalid-api-key\"\n    /* AuthErrorCode.INVALID_API_KEY */\n    );\n\n    const params = {\n      apiKey: auth.config.apiKey,\n      appName: auth.name,\n      authType,\n      redirectUrl,\n      v: SDK_VERSION,\n      eventId\n    };\n\n    if (provider instanceof FederatedAuthProvider) {\n      provider.setDefaultLanguage(auth.languageCode);\n      params.providerId = provider.providerId || '';\n\n      if (!isEmpty(provider.getCustomParameters())) {\n        params.customParameters = JSON.stringify(provider.getCustomParameters());\n      } // TODO set additionalParams from the provider as well?\n\n\n      for (const [key, value] of Object.entries(additionalParams || {})) {\n        params[key] = value;\n      }\n    }\n\n    if (provider instanceof BaseOAuthProvider) {\n      const scopes = provider.getScopes().filter(scope => scope !== '');\n\n      if (scopes.length > 0) {\n        params.scopes = scopes.join(',');\n      }\n    }\n\n    if (auth.tenantId) {\n      params.tid = auth.tenantId;\n    } // TODO: maybe set eid as endipointId\n    // TODO: maybe set fw as Frameworks.join(\",\")\n\n\n    const paramsDict = params;\n\n    for (const key of Object.keys(paramsDict)) {\n      if (paramsDict[key] === undefined) {\n        delete paramsDict[key];\n      }\n    } // Sets the App Check token to pass to the widget\n\n\n    const appCheckToken = yield auth._getAppCheckToken();\n    const appCheckTokenFragment = appCheckToken ? `#${FIREBASE_APP_CHECK_FRAGMENT_ID}=${encodeURIComponent(appCheckToken)}` : ''; // Start at index 1 to skip the leading '&' in the query string\n\n    return `${getHandlerBase(auth)}?${querystring(paramsDict).slice(1)}${appCheckTokenFragment}`;\n  });\n  return _getRedirectUrl2.apply(this, arguments);\n}\n\nfunction getHandlerBase({\n  config\n}) {\n  if (!config.emulator) {\n    return `https://${config.authDomain}/${WIDGET_PATH}`;\n  }\n\n  return _emulatorUrl(config, EMULATOR_WIDGET_PATH);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction _cordovaWindow() {\n  return window;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction _getProjectConfig(_x14) {\n  return _getProjectConfig2.apply(this, arguments);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * How long to wait after the app comes back into focus before concluding that\r\n * the user closed the sign in tab.\r\n */\n\n\nfunction _getProjectConfig2() {\n  _getProjectConfig2 = _asyncToGenerator(function* (auth, request = {}) {\n    return _performApiRequest(auth, \"GET\"\n    /* HttpMethod.GET */\n    , \"/v1/projects\"\n    /* Endpoint.GET_PROJECT_CONFIG */\n    , request);\n  });\n  return _getProjectConfig2.apply(this, arguments);\n}\n\nconst REDIRECT_TIMEOUT_MS = 2000;\n/**\r\n * Generates the URL for the OAuth handler.\r\n */\n\nfunction _generateHandlerUrl(_x15, _x16, _x17) {\n  return _generateHandlerUrl2.apply(this, arguments);\n}\n/**\r\n * Validates that this app is valid for this project configuration\r\n */\n\n\nfunction _generateHandlerUrl2() {\n  _generateHandlerUrl2 = _asyncToGenerator(function* (auth, event, provider) {\n    var _a; // Get the cordova plugins\n\n\n    const {\n      BuildInfo\n    } = _cordovaWindow();\n\n    debugAssert(event.sessionId, 'AuthEvent did not contain a session ID');\n    const sessionDigest = yield computeSha256(event.sessionId);\n    const additionalParams = {};\n\n    if (_isIOS()) {\n      // iOS app identifier\n      additionalParams['ibi'] = BuildInfo.packageName;\n    } else if (_isAndroid()) {\n      // Android app identifier\n      additionalParams['apn'] = BuildInfo.packageName;\n    } else {\n      _fail(auth, \"operation-not-supported-in-this-environment\"\n      /* AuthErrorCode.OPERATION_NOT_SUPPORTED */\n      );\n    } // Add the display name if available\n\n\n    if (BuildInfo.displayName) {\n      additionalParams['appDisplayName'] = BuildInfo.displayName;\n    } // Attached the hashed session ID\n\n\n    additionalParams['sessionId'] = sessionDigest;\n    return _getRedirectUrl(auth, provider, event.type, undefined, (_a = event.eventId) !== null && _a !== void 0 ? _a : undefined, additionalParams);\n  });\n  return _generateHandlerUrl2.apply(this, arguments);\n}\n\nfunction _validateOrigin(_x18) {\n  return _validateOrigin2.apply(this, arguments);\n}\n\nfunction _validateOrigin2() {\n  _validateOrigin2 = _asyncToGenerator(function* (auth) {\n    const {\n      BuildInfo\n    } = _cordovaWindow();\n\n    const request = {};\n\n    if (_isIOS()) {\n      request.iosBundleId = BuildInfo.packageName;\n    } else if (_isAndroid()) {\n      request.androidPackageName = BuildInfo.packageName;\n    } else {\n      _fail(auth, \"operation-not-supported-in-this-environment\"\n      /* AuthErrorCode.OPERATION_NOT_SUPPORTED */\n      );\n    } // Will fail automatically if package name is not authorized\n\n\n    yield _getProjectConfig(auth, request);\n  });\n  return _validateOrigin2.apply(this, arguments);\n}\n\nfunction _performRedirect(handlerUrl) {\n  // Get the cordova plugins\n  const {\n    cordova\n  } = _cordovaWindow();\n\n  return new Promise(resolve => {\n    cordova.plugins.browsertab.isAvailable(browserTabIsAvailable => {\n      let iabRef = null;\n\n      if (browserTabIsAvailable) {\n        cordova.plugins.browsertab.openUrl(handlerUrl);\n      } else {\n        // TODO: Return the inappbrowser ref that's returned from the open call\n        iabRef = cordova.InAppBrowser.open(handlerUrl, _isIOS7Or8() ? '_blank' : '_system', 'location=yes');\n      }\n\n      resolve(iabRef);\n    });\n  });\n}\n/**\r\n * This function waits for app activity to be seen before resolving. It does\r\n * this by attaching listeners to various dom events. Once the app is determined\r\n * to be visible, this promise resolves. AFTER that resolution, the listeners\r\n * are detached and any browser tabs left open will be closed.\r\n */\n\n\nfunction _waitForAppResume(_x19, _x20, _x21) {\n  return _waitForAppResume2.apply(this, arguments);\n}\n/**\r\n * Checks the configuration of the Cordova environment. This has no side effect\r\n * if the configuration is correct; otherwise it throws an error with the\r\n * missing plugin.\r\n */\n\n\nfunction _waitForAppResume2() {\n  _waitForAppResume2 = _asyncToGenerator(function* (auth, eventListener, iabRef) {\n    // Get the cordova plugins\n    const {\n      cordova\n    } = _cordovaWindow();\n\n    let cleanup = () => {};\n\n    try {\n      yield new Promise((resolve, reject) => {\n        let onCloseTimer = null; // DEFINE ALL THE CALLBACKS =====\n\n        function authEventSeen() {\n          var _a; // Auth event was detected. Resolve this promise and close the extra\n          // window if it's still open.\n\n\n          resolve();\n          const closeBrowserTab = (_a = cordova.plugins.browsertab) === null || _a === void 0 ? void 0 : _a.close;\n\n          if (typeof closeBrowserTab === 'function') {\n            closeBrowserTab();\n          } // Close inappbrowser emebedded webview in iOS7 and 8 case if still\n          // open.\n\n\n          if (typeof (iabRef === null || iabRef === void 0 ? void 0 : iabRef.close) === 'function') {\n            iabRef.close();\n          }\n        }\n\n        function resumed() {\n          if (onCloseTimer) {\n            // This code already ran; do not rerun.\n            return;\n          }\n\n          onCloseTimer = window.setTimeout(() => {\n            // Wait two seeconds after resume then reject.\n            reject(_createError(auth, \"redirect-cancelled-by-user\"\n            /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */\n            ));\n          }, REDIRECT_TIMEOUT_MS);\n        }\n\n        function visibilityChanged() {\n          if ((document === null || document === void 0 ? void 0 : document.visibilityState) === 'visible') {\n            resumed();\n          }\n        } // ATTACH ALL THE LISTENERS =====\n        // Listen for the auth event\n\n\n        eventListener.addPassiveListener(authEventSeen); // Listen for resume and visibility events\n\n        document.addEventListener('resume', resumed, false);\n\n        if (_isAndroid()) {\n          document.addEventListener('visibilitychange', visibilityChanged, false);\n        } // SETUP THE CLEANUP FUNCTION =====\n\n\n        cleanup = () => {\n          eventListener.removePassiveListener(authEventSeen);\n          document.removeEventListener('resume', resumed, false);\n          document.removeEventListener('visibilitychange', visibilityChanged, false);\n\n          if (onCloseTimer) {\n            window.clearTimeout(onCloseTimer);\n          }\n        };\n      });\n    } finally {\n      cleanup();\n    }\n  });\n  return _waitForAppResume2.apply(this, arguments);\n}\n\nfunction _checkCordovaConfiguration(auth) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n  const win = _cordovaWindow(); // Check all dependencies installed.\n  // https://github.com/nordnet/cordova-universal-links-plugin\n  // Note that cordova-universal-links-plugin has been abandoned.\n  // A fork with latest fixes is available at:\n  // https://www.npmjs.com/package/cordova-universal-links-plugin-fix\n\n\n  _assert(typeof ((_a = win === null || win === void 0 ? void 0 : win.universalLinks) === null || _a === void 0 ? void 0 : _a.subscribe) === 'function', auth, \"invalid-cordova-configuration\"\n  /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */\n  , {\n    missingPlugin: 'cordova-universal-links-plugin-fix'\n  }); // https://www.npmjs.com/package/cordova-plugin-buildinfo\n\n\n  _assert(typeof ((_b = win === null || win === void 0 ? void 0 : win.BuildInfo) === null || _b === void 0 ? void 0 : _b.packageName) !== 'undefined', auth, \"invalid-cordova-configuration\"\n  /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */\n  , {\n    missingPlugin: 'cordova-plugin-buildInfo'\n  }); // https://github.com/google/cordova-plugin-browsertab\n\n\n  _assert(typeof ((_e = (_d = (_c = win === null || win === void 0 ? void 0 : win.cordova) === null || _c === void 0 ? void 0 : _c.plugins) === null || _d === void 0 ? void 0 : _d.browsertab) === null || _e === void 0 ? void 0 : _e.openUrl) === 'function', auth, \"invalid-cordova-configuration\"\n  /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */\n  , {\n    missingPlugin: 'cordova-plugin-browsertab'\n  });\n\n  _assert(typeof ((_h = (_g = (_f = win === null || win === void 0 ? void 0 : win.cordova) === null || _f === void 0 ? void 0 : _f.plugins) === null || _g === void 0 ? void 0 : _g.browsertab) === null || _h === void 0 ? void 0 : _h.isAvailable) === 'function', auth, \"invalid-cordova-configuration\"\n  /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */\n  , {\n    missingPlugin: 'cordova-plugin-browsertab'\n  }); // https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/\n\n\n  _assert(typeof ((_k = (_j = win === null || win === void 0 ? void 0 : win.cordova) === null || _j === void 0 ? void 0 : _j.InAppBrowser) === null || _k === void 0 ? void 0 : _k.open) === 'function', auth, \"invalid-cordova-configuration\"\n  /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */\n  , {\n    missingPlugin: 'cordova-plugin-inappbrowser'\n  });\n}\n/**\r\n * Computes the SHA-256 of a session ID. The SubtleCrypto interface is only\r\n * available in \"secure\" contexts, which covers Cordova (which is served on a file\r\n * protocol).\r\n */\n\n\nfunction computeSha256(_x22) {\n  return _computeSha.apply(this, arguments);\n}\n\nfunction _computeSha() {\n  _computeSha = _asyncToGenerator(function* (sessionId) {\n    const bytes = stringToArrayBuffer(sessionId); // TODO: For IE11 crypto has a different name and this operation comes back\n    //       as an object, not a promise. This is the old proposed standard that\n    //       is used by IE11:\n    // https://www.w3.org/TR/2013/WD-WebCryptoAPI-20130108/#cryptooperation-interface\n\n    const buf = yield crypto.subtle.digest('SHA-256', bytes);\n    const arr = Array.from(new Uint8Array(buf));\n    return arr.map(num => num.toString(16).padStart(2, '0')).join('');\n  });\n  return _computeSha.apply(this, arguments);\n}\n\nfunction stringToArrayBuffer(str) {\n  // This function is only meant to deal with an ASCII charset and makes\n  // certain simplifying assumptions.\n  debugAssert(/[0-9a-zA-Z]+/.test(str), 'Can only convert alpha-numeric strings');\n\n  if (typeof TextEncoder !== 'undefined') {\n    return new TextEncoder().encode(str);\n  }\n\n  const buff = new ArrayBuffer(str.length);\n  const view = new Uint8Array(buff);\n\n  for (let i = 0; i < str.length; i++) {\n    view[i] = str.charCodeAt(i);\n  }\n\n  return view;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// The amount of time to store the UIDs of seen events; this is\n// set to 10 min by default\n\n\nconst EVENT_DUPLICATION_CACHE_DURATION_MS = 10 * 60 * 1000;\n\nclass AuthEventManager {\n  constructor(auth) {\n    this.auth = auth;\n    this.cachedEventUids = new Set();\n    this.consumers = new Set();\n    this.queuedRedirectEvent = null;\n    this.hasHandledPotentialRedirect = false;\n    this.lastProcessedEventTime = Date.now();\n  }\n\n  registerConsumer(authEventConsumer) {\n    this.consumers.add(authEventConsumer);\n\n    if (this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, authEventConsumer)) {\n      this.sendToConsumer(this.queuedRedirectEvent, authEventConsumer);\n      this.saveEventToCache(this.queuedRedirectEvent);\n      this.queuedRedirectEvent = null;\n    }\n  }\n\n  unregisterConsumer(authEventConsumer) {\n    this.consumers.delete(authEventConsumer);\n  }\n\n  onEvent(event) {\n    // Check if the event has already been handled\n    if (this.hasEventBeenHandled(event)) {\n      return false;\n    }\n\n    let handled = false;\n    this.consumers.forEach(consumer => {\n      if (this.isEventForConsumer(event, consumer)) {\n        handled = true;\n        this.sendToConsumer(event, consumer);\n        this.saveEventToCache(event);\n      }\n    });\n\n    if (this.hasHandledPotentialRedirect || !isRedirectEvent(event)) {\n      // If we've already seen a redirect before, or this is a popup event,\n      // bail now\n      return handled;\n    }\n\n    this.hasHandledPotentialRedirect = true; // If the redirect wasn't handled, hang on to it\n\n    if (!handled) {\n      this.queuedRedirectEvent = event;\n      handled = true;\n    }\n\n    return handled;\n  }\n\n  sendToConsumer(event, consumer) {\n    var _a;\n\n    if (event.error && !isNullRedirectEvent(event)) {\n      const code = ((_a = event.error.code) === null || _a === void 0 ? void 0 : _a.split('auth/')[1]) || \"internal-error\"\n      /* AuthErrorCode.INTERNAL_ERROR */\n      ;\n      consumer.onError(_createError(this.auth, code));\n    } else {\n      consumer.onAuthEvent(event);\n    }\n  }\n\n  isEventForConsumer(event, consumer) {\n    const eventIdMatches = consumer.eventId === null || !!event.eventId && event.eventId === consumer.eventId;\n    return consumer.filter.includes(event.type) && eventIdMatches;\n  }\n\n  hasEventBeenHandled(event) {\n    if (Date.now() - this.lastProcessedEventTime >= EVENT_DUPLICATION_CACHE_DURATION_MS) {\n      this.cachedEventUids.clear();\n    }\n\n    return this.cachedEventUids.has(eventUid(event));\n  }\n\n  saveEventToCache(event) {\n    this.cachedEventUids.add(eventUid(event));\n    this.lastProcessedEventTime = Date.now();\n  }\n\n}\n\nfunction eventUid(e) {\n  return [e.type, e.eventId, e.sessionId, e.tenantId].filter(v => v).join('-');\n}\n\nfunction isNullRedirectEvent({\n  type,\n  error\n}) {\n  return type === \"unknown\"\n  /* AuthEventType.UNKNOWN */\n  && (error === null || error === void 0 ? void 0 : error.code) === `auth/${\"no-auth-event\"\n  /* AuthErrorCode.NO_AUTH_EVENT */\n  }`;\n}\n\nfunction isRedirectEvent(event) {\n  switch (event.type) {\n    case \"signInViaRedirect\"\n    /* AuthEventType.SIGN_IN_VIA_REDIRECT */\n    :\n    case \"linkViaRedirect\"\n    /* AuthEventType.LINK_VIA_REDIRECT */\n    :\n    case \"reauthViaRedirect\"\n    /* AuthEventType.REAUTH_VIA_REDIRECT */\n    :\n      return true;\n\n    case \"unknown\"\n    /* AuthEventType.UNKNOWN */\n    :\n      return isNullRedirectEvent(event);\n\n    default:\n      return false;\n  }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction _iframeCannotSyncWebStorage() {\n  const ua = getUA();\n  return _isSafari(ua) || _isIOS(ua);\n} // The polling period in case events are not supported\n\n\nconst _POLLING_INTERVAL_MS = 1000; // The IE 10 localStorage cross tab synchronization delay in milliseconds\n\nconst IE10_LOCAL_STORAGE_SYNC_DELAY = 10;\n\nclass BrowserLocalPersistence extends BrowserPersistenceClass {\n  constructor() {\n    super(() => window.localStorage, \"LOCAL\"\n    /* PersistenceType.LOCAL */\n    );\n\n    this.boundEventHandler = (event, poll) => this.onStorageEvent(event, poll);\n\n    this.listeners = {};\n    this.localCache = {}; // setTimeout return value is platform specific\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    this.pollTimer = null; // Safari or iOS browser and embedded in an iframe.\n\n    this.safariLocalStorageNotSynced = _iframeCannotSyncWebStorage() && _isIframe(); // Whether to use polling instead of depending on window events\n\n    this.fallbackToPolling = _isMobileBrowser();\n    this._shouldAllowMigration = true;\n  }\n\n  forAllChangedKeys(cb) {\n    // Check all keys with listeners on them.\n    for (const key of Object.keys(this.listeners)) {\n      // Get value from localStorage.\n      const newValue = this.storage.getItem(key);\n      const oldValue = this.localCache[key]; // If local map value does not match, trigger listener with storage event.\n      // Differentiate this simulated event from the real storage event.\n\n      if (newValue !== oldValue) {\n        cb(key, oldValue, newValue);\n      }\n    }\n  }\n\n  onStorageEvent(event, poll = false) {\n    // Key would be null in some situations, like when localStorage is cleared\n    if (!event.key) {\n      this.forAllChangedKeys((key, _oldValue, newValue) => {\n        this.notifyListeners(key, newValue);\n      });\n      return;\n    }\n\n    const key = event.key; // Check the mechanism how this event was detected.\n    // The first event will dictate the mechanism to be used.\n\n    if (poll) {\n      // Environment detects storage changes via polling.\n      // Remove storage event listener to prevent possible event duplication.\n      this.detachListener();\n    } else {\n      // Environment detects storage changes via storage event listener.\n      // Remove polling listener to prevent possible event duplication.\n      this.stopPolling();\n    } // Safari embedded iframe. Storage event will trigger with the delta\n    // changes but no changes will be applied to the iframe localStorage.\n\n\n    if (this.safariLocalStorageNotSynced) {\n      // Get current iframe page value.\n      const storedValue = this.storage.getItem(key); // Value not synchronized, synchronize manually.\n\n      if (event.newValue !== storedValue) {\n        if (event.newValue !== null) {\n          // Value changed from current value.\n          this.storage.setItem(key, event.newValue);\n        } else {\n          // Current value deleted.\n          this.storage.removeItem(key);\n        }\n      } else if (this.localCache[key] === event.newValue && !poll) {\n        // Already detected and processed, do not trigger listeners again.\n        return;\n      }\n    }\n\n    const triggerListeners = () => {\n      // Keep local map up to date in case storage event is triggered before\n      // poll.\n      const storedValue = this.storage.getItem(key);\n\n      if (!poll && this.localCache[key] === storedValue) {\n        // Real storage event which has already been detected, do nothing.\n        // This seems to trigger in some IE browsers for some reason.\n        return;\n      }\n\n      this.notifyListeners(key, storedValue);\n    };\n\n    const storedValue = this.storage.getItem(key);\n\n    if (_isIE10() && storedValue !== event.newValue && event.newValue !== event.oldValue) {\n      // IE 10 has this weird bug where a storage event would trigger with the\n      // correct key, oldValue and newValue but localStorage.getItem(key) does\n      // not yield the updated value until a few milliseconds. This ensures\n      // this recovers from that situation.\n      setTimeout(triggerListeners, IE10_LOCAL_STORAGE_SYNC_DELAY);\n    } else {\n      triggerListeners();\n    }\n  }\n\n  notifyListeners(key, value) {\n    this.localCache[key] = value;\n    const listeners = this.listeners[key];\n\n    if (listeners) {\n      for (const listener of Array.from(listeners)) {\n        listener(value ? JSON.parse(value) : value);\n      }\n    }\n  }\n\n  startPolling() {\n    this.stopPolling();\n    this.pollTimer = setInterval(() => {\n      this.forAllChangedKeys((key, oldValue, newValue) => {\n        this.onStorageEvent(new StorageEvent('storage', {\n          key,\n          oldValue,\n          newValue\n        }),\n        /* poll */\n        true);\n      });\n    }, _POLLING_INTERVAL_MS);\n  }\n\n  stopPolling() {\n    if (this.pollTimer) {\n      clearInterval(this.pollTimer);\n      this.pollTimer = null;\n    }\n  }\n\n  attachListener() {\n    window.addEventListener('storage', this.boundEventHandler);\n  }\n\n  detachListener() {\n    window.removeEventListener('storage', this.boundEventHandler);\n  }\n\n  _addListener(key, listener) {\n    if (Object.keys(this.listeners).length === 0) {\n      // Whether browser can detect storage event when it had already been pushed to the background.\n      // This may happen in some mobile browsers. A localStorage change in the foreground window\n      // will not be detected in the background window via the storage event.\n      // This was detected in iOS 7.x mobile browsers\n      if (this.fallbackToPolling) {\n        this.startPolling();\n      } else {\n        this.attachListener();\n      }\n    }\n\n    if (!this.listeners[key]) {\n      this.listeners[key] = new Set(); // Populate the cache to avoid spuriously triggering on first poll.\n\n      this.localCache[key] = this.storage.getItem(key);\n    }\n\n    this.listeners[key].add(listener);\n  }\n\n  _removeListener(key, listener) {\n    if (this.listeners[key]) {\n      this.listeners[key].delete(listener);\n\n      if (this.listeners[key].size === 0) {\n        delete this.listeners[key];\n      }\n    }\n\n    if (Object.keys(this.listeners).length === 0) {\n      this.detachListener();\n      this.stopPolling();\n    }\n  } // Update local cache on base operations:\n\n\n  _set(key, value) {\n    var _superprop_get_set = () => super._set,\n        _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _superprop_get_set().call(_this5, key, value);\n      _this5.localCache[key] = JSON.stringify(value);\n    })();\n  }\n\n  _get(key) {\n    var _superprop_get_get = () => super._get,\n        _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const value = yield _superprop_get_get().call(_this6, key);\n      _this6.localCache[key] = JSON.stringify(value);\n      return value;\n    })();\n  }\n\n  _remove(key) {\n    var _superprop_get_remove = () => super._remove,\n        _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _superprop_get_remove().call(_this7, key);\n      delete _this7.localCache[key];\n    })();\n  }\n\n}\n\nBrowserLocalPersistence.type = 'LOCAL';\n/**\r\n * An implementation of {@link Persistence} of type `LOCAL` using `localStorage`\r\n * for the underlying storage.\r\n *\r\n * @public\r\n */\n\nconst browserLocalPersistence = BrowserLocalPersistence;\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst SESSION_ID_LENGTH = 20;\n/** Custom AuthEventManager that adds passive listeners to events */\n\nclass CordovaAuthEventManager extends AuthEventManager {\n  constructor() {\n    super(...arguments);\n    this.passiveListeners = new Set();\n    this.initPromise = new Promise(resolve => {\n      this.resolveInialized = resolve;\n    });\n  }\n\n  addPassiveListener(cb) {\n    this.passiveListeners.add(cb);\n  }\n\n  removePassiveListener(cb) {\n    this.passiveListeners.delete(cb);\n  } // In a Cordova environment, this manager can live through multiple redirect\n  // operations\n\n\n  resetRedirect() {\n    this.queuedRedirectEvent = null;\n    this.hasHandledPotentialRedirect = false;\n  }\n  /** Override the onEvent method */\n\n\n  onEvent(event) {\n    this.resolveInialized();\n    this.passiveListeners.forEach(cb => cb(event));\n    return super.onEvent(event);\n  }\n\n  initialized() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this8.initPromise;\n    })();\n  }\n\n}\n/**\r\n * Generates a (partial) {@link AuthEvent}.\r\n */\n\n\nfunction _generateNewEvent(auth, type, eventId = null) {\n  return {\n    type,\n    eventId,\n    urlResponse: null,\n    sessionId: generateSessionId(),\n    postBody: null,\n    tenantId: auth.tenantId,\n    error: _createError(auth, \"no-auth-event\"\n    /* AuthErrorCode.NO_AUTH_EVENT */\n    )\n  };\n}\n\nfunction _savePartialEvent(auth, event) {\n  return storage()._set(persistenceKey(auth), event);\n}\n\nfunction _getAndRemoveEvent(_x23) {\n  return _getAndRemoveEvent2.apply(this, arguments);\n}\n\nfunction _getAndRemoveEvent2() {\n  _getAndRemoveEvent2 = _asyncToGenerator(function* (auth) {\n    const event = yield storage()._get(persistenceKey(auth));\n\n    if (event) {\n      yield storage()._remove(persistenceKey(auth));\n    }\n\n    return event;\n  });\n  return _getAndRemoveEvent2.apply(this, arguments);\n}\n\nfunction _eventFromPartialAndUrl(partialEvent, url) {\n  var _a, _b; // Parse the deep link within the dynamic link URL.\n\n\n  const callbackUrl = _getDeepLinkFromCallback(url); // Confirm it is actually a callback URL.\n  // Currently the universal link will be of this format:\n  // https://<AUTH_DOMAIN>/__/auth/callback<OAUTH_RESPONSE>\n  // This is a fake URL but is not intended to take the user anywhere\n  // and just redirect to the app.\n\n\n  if (callbackUrl.includes('/__/auth/callback')) {\n    // Check if there is an error in the URL.\n    // This mechanism is also used to pass errors back to the app:\n    // https://<AUTH_DOMAIN>/__/auth/callback?firebaseError=<STRINGIFIED_ERROR>\n    const params = searchParamsOrEmpty(callbackUrl); // Get the error object corresponding to the stringified error if found.\n\n    const errorObject = params['firebaseError'] ? parseJsonOrNull(decodeURIComponent(params['firebaseError'])) : null;\n    const code = (_b = (_a = errorObject === null || errorObject === void 0 ? void 0 : errorObject['code']) === null || _a === void 0 ? void 0 : _a.split('auth/')) === null || _b === void 0 ? void 0 : _b[1];\n    const error = code ? _createError(code) : null;\n\n    if (error) {\n      return {\n        type: partialEvent.type,\n        eventId: partialEvent.eventId,\n        tenantId: partialEvent.tenantId,\n        error,\n        urlResponse: null,\n        sessionId: null,\n        postBody: null\n      };\n    } else {\n      return {\n        type: partialEvent.type,\n        eventId: partialEvent.eventId,\n        tenantId: partialEvent.tenantId,\n        sessionId: partialEvent.sessionId,\n        urlResponse: callbackUrl,\n        postBody: null\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction generateSessionId() {\n  const chars = [];\n  const allowedChars = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n  for (let i = 0; i < SESSION_ID_LENGTH; i++) {\n    const idx = Math.floor(Math.random() * allowedChars.length);\n    chars.push(allowedChars.charAt(idx));\n  }\n\n  return chars.join('');\n}\n\nfunction storage() {\n  return _getInstance(browserLocalPersistence);\n}\n\nfunction persistenceKey(auth) {\n  return _persistenceKeyName(\"authEvent\"\n  /* KeyName.AUTH_EVENT */\n  , auth.config.apiKey, auth.name);\n}\n\nfunction parseJsonOrNull(json) {\n  try {\n    return JSON.parse(json);\n  } catch (e) {\n    return null;\n  }\n} // Exported for testing\n\n\nfunction _getDeepLinkFromCallback(url) {\n  const params = searchParamsOrEmpty(url);\n  const link = params['link'] ? decodeURIComponent(params['link']) : undefined; // Double link case (automatic redirect)\n\n  const doubleDeepLink = searchParamsOrEmpty(link)['link']; // iOS custom scheme links.\n\n  const iOSDeepLink = params['deep_link_id'] ? decodeURIComponent(params['deep_link_id']) : undefined;\n  const iOSDoubleDeepLink = searchParamsOrEmpty(iOSDeepLink)['link'];\n  return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;\n}\n/**\r\n * Optimistically tries to get search params from a string, or else returns an\r\n * empty search params object.\r\n */\n\n\nfunction searchParamsOrEmpty(url) {\n  if (!(url === null || url === void 0 ? void 0 : url.includes('?'))) {\n    return {};\n  }\n\n  const [_, ...rest] = url.split('?');\n  return querystringDecode(rest.join('?'));\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * How long to wait for the initial auth event before concluding no\r\n * redirect pending\r\n */\n\n\nconst INITIAL_EVENT_TIMEOUT_MS = 500;\n\nclass CordovaPopupRedirectResolver {\n  constructor() {\n    this._redirectPersistence = browserSessionPersistence;\n    this._shouldInitProactively = true; // This is lightweight for Cordova\n\n    this.eventManagers = new Map();\n    this.originValidationPromises = {};\n    this._completeRedirectFn = _getRedirectResult;\n    this._overrideRedirectResult = _overrideRedirectResult;\n  }\n\n  _initialize(auth) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = auth._key();\n\n      let manager = _this9.eventManagers.get(key);\n\n      if (!manager) {\n        manager = new CordovaAuthEventManager(auth);\n\n        _this9.eventManagers.set(key, manager);\n\n        _this9.attachCallbackListeners(auth, manager);\n      }\n\n      return manager;\n    })();\n  }\n\n  _openPopup(auth) {\n    _fail(auth, \"operation-not-supported-in-this-environment\"\n    /* AuthErrorCode.OPERATION_NOT_SUPPORTED */\n    );\n  }\n\n  _openRedirect(auth, provider, authType, eventId) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      _checkCordovaConfiguration(auth);\n\n      const manager = yield _this10._initialize(auth);\n      yield manager.initialized(); // Reset the persisted redirect states. This does not matter on Web where\n      // the redirect always blows away application state entirely. On Cordova,\n      // the app maintains control flow through the redirect.\n\n      manager.resetRedirect();\n\n      _clearRedirectOutcomes();\n\n      yield _this10._originValidation(auth);\n\n      const event = _generateNewEvent(auth, authType, eventId);\n\n      yield _savePartialEvent(auth, event);\n      const url = yield _generateHandlerUrl(auth, event, provider);\n      const iabRef = yield _performRedirect(url);\n      return _waitForAppResume(auth, manager, iabRef);\n    })();\n  }\n\n  _isIframeWebStorageSupported(_auth, _cb) {\n    throw new Error('Method not implemented.');\n  }\n\n  _originValidation(auth) {\n    const key = auth._key();\n\n    if (!this.originValidationPromises[key]) {\n      this.originValidationPromises[key] = _validateOrigin(auth);\n    }\n\n    return this.originValidationPromises[key];\n  }\n\n  attachCallbackListeners(auth, manager) {\n    // Get the global plugins\n    const {\n      universalLinks,\n      handleOpenURL,\n      BuildInfo\n    } = _cordovaWindow();\n\n    const noEventTimeout = setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n      // We didn't see that initial event. Clear any pending object and\n      // dispatch no event\n      yield _getAndRemoveEvent(auth);\n      manager.onEvent(generateNoEvent());\n    }), INITIAL_EVENT_TIMEOUT_MS);\n\n    const universalLinksCb = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (eventData) {\n        // We have an event so we can clear the no event timeout\n        clearTimeout(noEventTimeout);\n        const partialEvent = yield _getAndRemoveEvent(auth);\n        let finalEvent = null;\n\n        if (partialEvent && (eventData === null || eventData === void 0 ? void 0 : eventData['url'])) {\n          finalEvent = _eventFromPartialAndUrl(partialEvent, eventData['url']);\n        } // If finalEvent is never filled, trigger with no event\n\n\n        manager.onEvent(finalEvent || generateNoEvent());\n      });\n\n      return function universalLinksCb(_x24) {\n        return _ref3.apply(this, arguments);\n      };\n    }(); // Universal links subscriber doesn't exist for iOS, so we need to check\n\n\n    if (typeof universalLinks !== 'undefined' && typeof universalLinks.subscribe === 'function') {\n      universalLinks.subscribe(null, universalLinksCb);\n    } // iOS 7 or 8 custom URL schemes.\n    // This is also the current default behavior for iOS 9+.\n    // For this to work, cordova-plugin-customurlscheme needs to be installed.\n    // https://github.com/EddyVerbruggen/Custom-URL-scheme\n    // Do not overwrite the existing developer's URL handler.\n\n\n    const existingHandleOpenURL = handleOpenURL;\n    const packagePrefix = `${BuildInfo.packageName.toLowerCase()}://`;\n\n    _cordovaWindow().handleOpenURL = /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (url) {\n        if (url.toLowerCase().startsWith(packagePrefix)) {\n          // We want this intentionally to float\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          universalLinksCb({\n            url\n          });\n        } // Call the developer's handler if it is present.\n\n\n        if (typeof existingHandleOpenURL === 'function') {\n          try {\n            existingHandleOpenURL(url);\n          } catch (e) {\n            // This is a developer error. Don't stop the flow of the SDK.\n            console.error(e);\n          }\n        }\n      });\n\n      return function (_x25) {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n  }\n\n}\n/**\r\n * An implementation of {@link PopupRedirectResolver} suitable for Cordova\r\n * based applications.\r\n *\r\n * @public\r\n */\n\n\nconst cordovaPopupRedirectResolver = CordovaPopupRedirectResolver;\n\nfunction generateNoEvent() {\n  return {\n    type: \"unknown\"\n    /* AuthEventType.UNKNOWN */\n    ,\n    eventId: null,\n    sessionId: null,\n    urlResponse: null,\n    postBody: null,\n    tenantId: null,\n    error: _createError(\"no-auth-event\"\n    /* AuthErrorCode.NO_AUTH_EVENT */\n    )\n  };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.\n// It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it out\n// of autogenerated documentation pages to reduce accidental misuse.\n\n\nfunction addFrameworkForLogging(auth, framework) {\n  _castAuth(auth)._logFramework(framework);\n}\n\nexport { AuthPopup, _generateEventId, _getRedirectResult, _overrideRedirectResult, addFrameworkForLogging, cordovaPopupRedirectResolver }; //# sourceMappingURL=internal.js.map","map":null,"metadata":{},"sourceType":"module"}