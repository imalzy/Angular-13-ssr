{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _asyncToGenerator = require(\"/Users/imalzy/Documents/angular/technical-req-angular-13/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\n\nconst zlib = require(\"zlib\");\n\nconst compression_algorithms_1 = require(\"./compression-algorithms\");\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_1 = require(\"./filter\");\n\nconst logging = require(\"./logging\");\n\nconst isCompressionAlgorithmKey = key => {\n  return typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string';\n};\n\nclass CompressionHandler {\n  /**\n   * @param message Raw uncompressed message bytes\n   * @param compress Indicates whether the message should be compressed\n   * @return Framed message, compressed if applicable\n   */\n  writeMessage(message, compress) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let messageBuffer = message;\n\n      if (compress) {\n        messageBuffer = yield _this.compressMessage(messageBuffer);\n      }\n\n      const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n      output.writeUInt8(compress ? 1 : 0, 0);\n      output.writeUInt32BE(messageBuffer.length, 1);\n      messageBuffer.copy(output, 5);\n      return output;\n    })();\n  }\n  /**\n   * @param data Framed message, possibly compressed\n   * @return Uncompressed message\n   */\n\n\n  readMessage(data) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const compressed = data.readUInt8(0) === 1;\n      let messageBuffer = data.slice(5);\n\n      if (compressed) {\n        messageBuffer = yield _this2.decompressMessage(messageBuffer);\n      }\n\n      return messageBuffer;\n    })();\n  }\n\n}\n\nclass IdentityHandler extends CompressionHandler {\n  compressMessage(message) {\n    return _asyncToGenerator(function* () {\n      return message;\n    })();\n  }\n\n  writeMessage(message, compress) {\n    return _asyncToGenerator(function* () {\n      const output = Buffer.allocUnsafe(message.length + 5);\n      /* With \"identity\" compression, messages should always be marked as\n       * uncompressed */\n\n      output.writeUInt8(0, 0);\n      output.writeUInt32BE(message.length, 1);\n      message.copy(output, 5);\n      return output;\n    })();\n  }\n\n  decompressMessage(message) {\n    return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n  }\n\n}\n\nclass DeflateHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.deflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.inflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n}\n\nclass GzipHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.gzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.unzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n}\n\nclass UnknownHandler extends CompressionHandler {\n  constructor(compressionName) {\n    super();\n    this.compressionName = compressionName;\n  }\n\n  compressMessage(message) {\n    return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n  }\n\n  decompressMessage(message) {\n    // This should be unreachable\n    return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n  }\n\n}\n\nfunction getCompressionHandler(compressionName) {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n\n    case 'deflate':\n      return new DeflateHandler();\n\n    case 'gzip':\n      return new GzipHandler();\n\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\n\nclass CompressionFilter extends filter_1.BaseFilter {\n  constructor(channelOptions, sharedFilterConfig) {\n    var _a;\n\n    super();\n    this.sharedFilterConfig = sharedFilterConfig;\n    this.sendCompression = new IdentityHandler();\n    this.receiveCompression = new IdentityHandler();\n    this.currentCompressionAlgorithm = 'identity';\n    const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\n\n    if (compressionAlgorithmKey !== undefined) {\n      if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n        const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n        const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(',');\n        /**\n         * There are two possible situations here:\n         * 1) We don't have any info yet from the server about what compression it supports\n         *    In that case we should just use what the client tells us to use\n         * 2) We've previously received a response from the server including a grpc-accept-encoding header\n         *    In that case we only want to use the encoding chosen by the client if the server supports it\n         */\n\n        if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n          this.currentCompressionAlgorithm = clientSelectedEncoding;\n          this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);\n        }\n      } else {\n        logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n      }\n    }\n  }\n\n  sendMetadata(metadata) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const headers = yield metadata;\n      headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n      headers.set('accept-encoding', 'identity'); // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n\n      if (_this3.currentCompressionAlgorithm === 'identity') {\n        headers.remove('grpc-encoding');\n      } else {\n        headers.set('grpc-encoding', _this3.currentCompressionAlgorithm);\n      }\n\n      return headers;\n    })();\n  }\n\n  receiveMetadata(metadata) {\n    const receiveEncoding = metadata.get('grpc-encoding');\n\n    if (receiveEncoding.length > 0) {\n      const encoding = receiveEncoding[0];\n\n      if (typeof encoding === 'string') {\n        this.receiveCompression = getCompressionHandler(encoding);\n      }\n    }\n\n    metadata.remove('grpc-encoding');\n    /* Check to see if the compression we're using to send messages is supported by the server\n     * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n\n    const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];\n\n    if (serverSupportedEncodingsHeader) {\n      this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n      const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\n\n      if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n        this.sendCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n      }\n    }\n\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n\n  sendMessage(message) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n      /* This filter is special. The input message is the bare message bytes,\n       * and the output is a framed and possibly compressed message. For this\n       * reason, this filter should be at the bottom of the filter stack */\n\n\n      const resolvedMessage = yield message;\n      let compress;\n\n      if (_this4.sendCompression instanceof IdentityHandler) {\n        compress = false;\n      } else {\n        compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2\n        /* NoCompress */\n        ) === 0;\n      }\n\n      return {\n        message: yield _this4.sendCompression.writeMessage(resolvedMessage.message, compress),\n        flags: resolvedMessage.flags\n      };\n    })();\n  }\n\n  receiveMessage(message) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      /* This filter is also special. The input message is framed and possibly\n       * compressed, and the output message is deframed and uncompressed. So\n       * this is another reason that this filter should be at the bottom of the\n       * filter stack. */\n      return _this5.receiveCompression.readMessage(yield message);\n    })();\n  }\n\n}\n\nexports.CompressionFilter = CompressionFilter;\n\nclass CompressionFilterFactory {\n  constructor(channel, options) {\n    this.channel = channel;\n    this.options = options;\n    this.sharedFilterConfig = {};\n  }\n\n  createFilter(callStream) {\n    return new CompressionFilter(this.options, this.sharedFilterConfig);\n  }\n\n}\n\nexports.CompressionFilterFactory = CompressionFilterFactory; //# sourceMappingURL=compression-filter.js.map","map":null,"metadata":{},"sourceType":"script"}