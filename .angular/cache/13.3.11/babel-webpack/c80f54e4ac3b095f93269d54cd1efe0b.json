{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nclass BackoffTimeout {\n  constructor(callback, options) {\n    this.callback = callback;\n    /**\n     * The delay time at the start, and after each reset.\n     */\n\n    this.initialDelay = INITIAL_BACKOFF_MS;\n    /**\n     * The exponential backoff multiplier.\n     */\n\n    this.multiplier = BACKOFF_MULTIPLIER;\n    /**\n     * The maximum delay time\n     */\n\n    this.maxDelay = MAX_BACKOFF_MS;\n    /**\n     * The maximum fraction by which the delay time can randomly vary after\n     * applying the multiplier.\n     */\n\n    this.jitter = BACKOFF_JITTER;\n    /**\n     * Indicates whether the timer is currently running.\n     */\n\n    this.running = false;\n    /**\n     * Indicates whether the timer should keep the Node process running if no\n     * other async operation is doing so.\n     */\n\n    this.hasRef = true;\n    /**\n     * The time that the currently running timer was started. Only valid if\n     * running is true.\n     */\n\n    this.startTime = new Date();\n\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n\n  runTimer(delay) {\n    var _a, _b;\n\n    clearTimeout(this.timerId);\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, delay);\n\n    if (!this.hasRef) {\n      (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  /**\n   * Call the callback after the current amount of delay time\n   */\n\n\n  runOnce() {\n    this.running = true;\n    this.startTime = new Date();\n    this.runTimer(this.nextDelay);\n    const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n\n\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n  /**\n   * Reset the delay time to its initial value. If the timer is still running,\n   * retroactively apply that reset to the current timer.\n   */\n\n\n  reset() {\n    this.nextDelay = this.initialDelay;\n\n    if (this.running) {\n      const now = new Date();\n      const newEndTime = this.startTime;\n      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n      clearTimeout(this.timerId);\n\n      if (now < newEndTime) {\n        this.runTimer(newEndTime.getTime() - now.getTime());\n      } else {\n        this.running = false;\n      }\n    }\n  }\n  /**\n   * Check whether the timer is currently running.\n   */\n\n\n  isRunning() {\n    return this.running;\n  }\n  /**\n   * Set that while the timer is running, it should keep the Node process\n   * running.\n   */\n\n\n  ref() {\n    var _a, _b;\n\n    this.hasRef = true;\n    (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Set that while the timer is running, it should not keep the Node process\n   * running.\n   */\n\n\n  unref() {\n    var _a, _b;\n\n    this.hasRef = false;\n    (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n\n}\n\nexports.BackoffTimeout = BackoffTimeout; //# sourceMappingURL=backoff-timeout.js.map","map":null,"metadata":{},"sourceType":"script"}