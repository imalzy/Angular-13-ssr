{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _asyncToGenerator = require(\"/Users/imalzy/Documents/angular/technical-req-angular-13/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\n\nconst events_1 = require(\"events\");\n\nconst http2 = require(\"http2\");\n\nconst stream_1 = require(\"stream\");\n\nconst zlib = require(\"zlib\");\n\nconst util_1 = require(\"util\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst stream_decoder_1 = require(\"./stream-decoder\");\n\nconst logging = require(\"./logging\");\n\nconst TRACER_NAME = 'server_call';\nconst unzip = util_1.promisify(zlib.unzip);\nconst inflate = util_1.promisify(zlib.inflate);\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001\n};\nconst defaultResponseHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity',\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto'\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true\n};\n\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n  constructor(call, metadata, request) {\n    super();\n    this.call = call;\n    this.metadata = metadata;\n    this.request = request;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n  getPath() {\n    return this.call.getPath();\n  }\n\n}\n\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\n\nclass ServerReadableStreamImpl extends stream_1.Readable {\n  constructor(call, metadata, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n  }\n\n  _read(size) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n\n    this.call.resume();\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n  getPath() {\n    return this.call.getPath();\n  }\n\n}\n\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\n\nclass ServerWritableStreamImpl extends stream_1.Writable {\n  constructor(call, metadata, serialize, request) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.request = request;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n  getPath() {\n    return this.call.getPath();\n  }\n\n  _write(chunk, encoding, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  callback) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      this.emit('error', err);\n    }\n\n    callback();\n  }\n\n  _final(callback) {\n    this.call.sendStatus({\n      code: constants_1.Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata\n    });\n    callback(null);\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n\n}\n\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\n\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n  constructor(call, metadata, serialize, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n\n  getPath() {\n    return this.call.getPath();\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n\n}\n\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final; // Internal class that wraps the HTTP2 request.\n\nclass Http2ServerCallStream extends events_1.EventEmitter {\n  constructor(stream, handler, options) {\n    super();\n    this.stream = stream;\n    this.handler = handler;\n    this.options = options;\n    this.cancelled = false;\n    this.deadlineTimer = null;\n    this.statusSent = false;\n    this.deadline = Infinity;\n    this.wantTrailers = false;\n    this.metadataSent = false;\n    this.canPush = false;\n    this.isPushPending = false;\n    this.bufferedMessages = [];\n    this.messagesToPush = [];\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.stream.once('error', err => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n    this.stream.once('close', () => {\n      var _a;\n\n      trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' stream closed with rstCode ' + this.stream.rstCode);\n\n      if (!this.statusSent) {\n        this.cancelled = true;\n        this.emit('cancelled', 'cancelled');\n        this.emit('streamEnd', false);\n        this.sendStatus({\n          code: constants_1.Status.CANCELLED,\n          details: 'Cancelled by client',\n          metadata: null\n        });\n      }\n    });\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    }\n  }\n\n  checkCancelled() {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed || this.stream.closed) {\n      this.cancelled = true;\n    }\n\n    return this.cancelled;\n  }\n\n  getDecompressedMessage(message, encoding) {\n    if (encoding === 'deflate') {\n      return inflate(message.subarray(5));\n    } else if (encoding === 'gzip') {\n      return unzip(message.subarray(5));\n    } else if (encoding === 'identity') {\n      return message.subarray(5);\n    }\n\n    return Promise.reject({\n      code: constants_1.Status.UNIMPLEMENTED,\n      details: `Received message compressed with unsupported encoding \"${encoding}\"`\n    });\n  }\n\n  sendMetadata(customMetadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.metadataSent) {\n      return;\n    }\n\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null; // TODO(cjihrig): Include compression headers.\n\n    const headers = Object.assign(Object.assign({}, defaultResponseHeaders), custom);\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n\n  receiveMetadata(headers) {\n    const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      trace('Request to ' + this.handler.path + ' received headers ' + JSON.stringify(metadata.toJSON()));\n    } // TODO(cjihrig): Receive compression metadata.\n\n\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n\n      if (match === null) {\n        const err = new Error('Invalid deadline');\n        err.code = constants_1.Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return metadata;\n      }\n\n      const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    } // Remove several headers that should not be propagated to the application\n\n\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n\n  receiveUnaryMessage(encoding, next) {\n    const {\n      stream\n    } = this;\n    let receivedLength = 0;\n    const call = this;\n    const body = [];\n    const limit = this.maxReceiveMessageSize;\n    stream.on('data', onData);\n    stream.on('end', onEnd);\n    stream.on('error', onEnd);\n\n    function onData(chunk) {\n      receivedLength += chunk.byteLength;\n\n      if (limit !== -1 && receivedLength > limit) {\n        stream.removeListener('data', onData);\n        stream.removeListener('end', onEnd);\n        stream.removeListener('error', onEnd);\n        next({\n          code: constants_1.Status.RESOURCE_EXHAUSTED,\n          details: `Received message larger than max (${receivedLength} vs. ${limit})`\n        });\n        return;\n      }\n\n      body.push(chunk);\n    }\n\n    function onEnd(err) {\n      stream.removeListener('data', onData);\n      stream.removeListener('end', onEnd);\n      stream.removeListener('error', onEnd);\n\n      if (err !== undefined) {\n        next({\n          code: constants_1.Status.INTERNAL,\n          details: err.message\n        });\n        return;\n      }\n\n      if (receivedLength === 0) {\n        next({\n          code: constants_1.Status.INTERNAL,\n          details: 'received empty unary message'\n        });\n        return;\n      }\n\n      call.emit('receiveMessage');\n      const requestBytes = Buffer.concat(body, receivedLength);\n      const compressed = requestBytes.readUInt8(0) === 1;\n      const compressedMessageEncoding = compressed ? encoding : 'identity';\n      const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n\n      if (Buffer.isBuffer(decompressedMessage)) {\n        call.safeDeserializeMessage(decompressedMessage, next);\n        return;\n      }\n\n      decompressedMessage.then(decompressed => call.safeDeserializeMessage(decompressed, next), err => next(err.code ? err : {\n        code: constants_1.Status.INTERNAL,\n        details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`\n      }));\n    }\n  }\n\n  safeDeserializeMessage(buffer, next) {\n    try {\n      next(null, this.deserializeMessage(buffer));\n    } catch (err) {\n      err.code = constants_1.Status.INTERNAL;\n      next(err);\n    }\n  }\n\n  serializeMessage(value) {\n    const messageBuffer = this.handler.serialize(value); // TODO(cjihrig): Call compression aware serializeMessage().\n\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n\n  deserializeMessage(bytes) {\n    return this.handler.deserialize(bytes);\n  }\n\n  sendUnaryMessage(err, value, metadata, flags) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.checkCancelled()) {\n        return;\n      }\n\n      if (metadata === undefined) {\n        metadata = null;\n      }\n\n      if (err) {\n        if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n          err.metadata = metadata;\n        }\n\n        _this.sendError(err);\n\n        return;\n      }\n\n      try {\n        const response = _this.serializeMessage(value);\n\n        _this.write(response);\n\n        _this.sendStatus({\n          code: constants_1.Status.OK,\n          details: 'OK',\n          metadata\n        });\n      } catch (err) {\n        err.code = constants_1.Status.INTERNAL;\n\n        _this.sendError(err);\n      }\n    })();\n  }\n\n  sendStatus(statusObj) {\n    var _a;\n\n    this.emit('callEnd', statusObj.code);\n    this.emit('streamEnd', statusObj.code === constants_1.Status.OK);\n\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' ended with status code: ' + constants_1.Status[statusObj.code] + ' details: ' + statusObj.details);\n    if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n\n    if (!this.wantTrailers) {\n      this.wantTrailers = true;\n      this.stream.once('wantTrailers', () => {\n        var _a;\n\n        const trailersToSend = Object.assign({\n          [GRPC_STATUS_HEADER]: statusObj.code,\n          [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n        }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n        this.stream.sendTrailers(trailersToSend);\n        this.statusSent = true;\n      });\n      this.sendMetadata();\n      this.stream.end();\n    }\n  }\n\n  sendError(error) {\n    const status = {\n      code: constants_1.Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata: 'metadata' in error && error.metadata !== undefined ? error.metadata : null\n    };\n\n    if ('code' in error && typeof error.code === 'number' && Number.isInteger(error.code)) {\n      status.code = error.code;\n\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details;\n      }\n    }\n\n    this.sendStatus(status);\n  }\n\n  write(chunk) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n      this.sendError({\n        code: constants_1.Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n      });\n      return;\n    }\n\n    this.sendMetadata();\n    this.emit('sendMessage');\n    return this.stream.write(chunk);\n  }\n\n  resume() {\n    this.stream.resume();\n  }\n\n  setupSurfaceCall(call) {\n    this.once('cancelled', reason => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n    this.once('callEnd', status => call.emit('callEnd', status));\n  }\n\n  setupReadable(readable, encoding) {\n    var _this2 = this;\n\n    const decoder = new stream_decoder_1.StreamDecoder();\n    let readsDone = false;\n    let pendingMessageProcessing = false;\n    let pushedEnd = false;\n\n    const maybePushEnd = () => {\n      if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n        pushedEnd = true;\n        this.pushOrBufferMessage(readable, null);\n      }\n    };\n\n    this.stream.on('data', /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (data) {\n        const messages = decoder.write(data);\n        pendingMessageProcessing = true;\n\n        _this2.stream.pause();\n\n        for (const message of messages) {\n          if (_this2.maxReceiveMessageSize !== -1 && message.length > _this2.maxReceiveMessageSize) {\n            _this2.sendError({\n              code: constants_1.Status.RESOURCE_EXHAUSTED,\n              details: `Received message larger than max (${message.length} vs. ${_this2.maxReceiveMessageSize})`\n            });\n\n            return;\n          }\n\n          _this2.emit('receiveMessage');\n\n          const compressed = message.readUInt8(0) === 1;\n          const compressedMessageEncoding = compressed ? encoding : 'identity';\n          const decompressedMessage = yield _this2.getDecompressedMessage(message, compressedMessageEncoding); // Encountered an error with decompression; it'll already have been propogated back\n          // Just return early\n\n          if (!decompressedMessage) return;\n\n          _this2.pushOrBufferMessage(readable, decompressedMessage);\n        }\n\n        pendingMessageProcessing = false;\n\n        _this2.stream.resume();\n\n        maybePushEnd();\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    this.stream.once('end', () => {\n      readsDone = true;\n      maybePushEnd();\n    });\n  }\n\n  consumeUnpushedMessages(readable) {\n    this.canPush = true;\n\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n\n    return this.canPush;\n  }\n\n  pushOrBufferMessage(readable, messageBytes) {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      this.pushMessage(readable, messageBytes);\n    }\n  }\n\n  pushMessage(readable, messageBytes) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (messageBytes === null) {\n        trace('Received end of stream');\n\n        if (_this3.canPush) {\n          readable.push(null);\n        } else {\n          _this3.messagesToPush.push(null);\n        }\n\n        return;\n      }\n\n      trace('Received message of length ' + messageBytes.length);\n      _this3.isPushPending = true;\n\n      try {\n        const deserialized = yield _this3.deserializeMessage(messageBytes);\n\n        if (_this3.canPush) {\n          if (!readable.push(deserialized)) {\n            _this3.canPush = false;\n\n            _this3.stream.pause();\n          }\n        } else {\n          _this3.messagesToPush.push(deserialized);\n        }\n      } catch (error) {\n        // Ignore any remaining messages when errors occur.\n        _this3.bufferedMessages.length = 0;\n\n        if (!('code' in error && typeof error.code === 'number' && Number.isInteger(error.code) && error.code >= constants_1.Status.OK && error.code <= constants_1.Status.UNAUTHENTICATED)) {\n          // The error code is not a valid gRPC code so its being overwritten.\n          error.code = constants_1.Status.INTERNAL;\n        }\n\n        readable.emit('error', error);\n      }\n\n      _this3.isPushPending = false;\n\n      if (_this3.bufferedMessages.length > 0) {\n        _this3.pushMessage(readable, _this3.bufferedMessages.shift());\n      }\n    })();\n  }\n\n  getPeer() {\n    const socket = this.stream.session.socket;\n\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n\n  getDeadline() {\n    return this.deadline;\n  }\n\n  getPath() {\n    return this.handler.path;\n  }\n\n}\n\nexports.Http2ServerCallStream = Http2ServerCallStream;\n\nfunction handleExpiredDeadline(call) {\n  const err = new Error('Deadline exceeded');\n  err.code = constants_1.Status.DEADLINE_EXCEEDED;\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n} //# sourceMappingURL=server-call.js.map","map":null,"metadata":{},"sourceType":"script"}